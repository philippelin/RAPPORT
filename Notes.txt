iCommandes pour la config de Git :
Philippe lin@DESKTOP-JDG22M9 MINGW64 ~
$ git config --global user.name "philippelin"

Philippe lin@DESKTOP-JDG22M9 MINGW64 ~
$ git config  --global user.email "philippelin@gmail.com"

Philippe lin@DESKTOP-JDG22M9 MINGW64 ~
$ cd Documents/GitRepository

Philippe lin@DESKTOP-JDG22M9 MINGW64 ~/Documents/GitRepository
$ ls

Philippe lin@DESKTOP-JDG22M9 MINGW64 ~/Documents/GitRepository
$ mkdir monprojet

Philippe lin@DESKTOP-JDG22M9 MINGW64 ~/Documents/GitRepository
$ cd monprojet

Philippe lin@DESKTOP-JDG22M9 MINGW64 ~/Documents/GitRepository/monprojet
$ git init
Initialized empty Git repository in C:/Users/Phil/Documents/GitRepository/monprojet/.git/
-------------------------------------------------------------------------------------------------

un fichier a trois états :

etat de modification;
etat dit "stage"(EN) le fichier a été modifié et est près a etre sauvegardé;
etat dit "commit" le fichier est terminé et on veut l'enregistré;

Pour ajouter le fichier on utilise la commande : 
git add `nomDuFichier` (on l'a mit dans la "stageArea")

Ensuite on peut  le "commit" c-a-d le sauvegardé(éventuellement avec un message) avec la commande :
git commit [-m "leMessageDeDescription"]

On peut aussi ajouter et commit un fichier en meme temps : git commit -a -m "message"

On peut avoir un historique des changements(sauvegardes) faits avec : git log
Pour voir les fichiers qui n'ont pas été sauvegardés on peut utiliser la commande : git status

Déplacer un fichier ou le renommer :
git mv <ancienNom> <nouveauNom>

Supprimer un fichier :
git rm <file>

Toute action qui se fait doit etre "commit" sinon ne sera pas sauvegardé...

Comparer des commit : git diff <commitIndex1> <commitIndex2>


Pour recuperer des fichiers en ligne on va sur github et on recherche le projet
on copy ensuite son chemin (souvent ce sont des url ou des chemins de fichiers.)
on va ensuite le cloner dans notre repertoire avec la commande :

git clone <chemin>(c'est l'url qu'on a copié qui est sous deux formes:
					--git://<depot...>
					--https://<lien>
Si  le depot a été fait et que depuis il y a eu de nouvelles versions
on peut mettre à jour le depot avec la commande : git pull

Après modification si on veut envoyer les fichiers vers le projet principal( Si on
a les droits bien-sur) on a la commande : git push origin master

----------
Après il est posssible de revenir en arriere si on a mal fait quelque chose ou
suppimer un mauvais fichier sur le depot, avec la commande : 
get reset -hard HEAD (Annuler tous les changements depuis le dernier commit)
get reset -hard HEAD^
get revert <commitIndex>

--------------------------------------------------------------------------------
UTILISATION PLUS AVANCEE DE GIT (COLLABORATION)

Supposons que notre projet est un arbre...Alors une branche c'est une “copie” 
de votre projet pour développer et tester de nouvelles fonctionnalités sans 
impacter le projet de base.

Une branche, dans Git, est simplement un pointeur vers un commit.

Pour rappel, lorsqu’on effectue un commit, Git stocke en fait un
objet commit qui contient les nom et prénom de l’auteur du commit,
le message renseigné lors de la création du commit ainsi qu’un pointeur
vers l’instantané du contenu indexé et des pointeurs vers le ou les
commits précédant directement le commit courant.

La branche par défaut dans Git s’appelle master. Cette branche master va
se déplacer automatiquement à chaque nouveau commit pour pointer sur le 
dernier commit effectué tant qu’on reste sur cette branche.

En résumé, une branche est un pointeur vers un commit en particulier. 
Un commit est un objet qui contient un pointeur vers l’instantané du 
contenu indexé ainsi que des pointeurs vers le ou les commits le 
précédant directement.

Ainsi, créer une nouvelle branche dans Git crée simplement un nouveau
pointeur plutôt que de recopier l’intégralité du répertoire de travail.

-----CREER UNE NOUVELLE BRANCHE----
Pour créer une nouvelle branche, on utilise la commande:<git branch nom-de-la-branche>.
Cette syntaxe va créer un nouveau pointeur vers le dernier commit effectué (le commit courant).
A ce stade, vous allez donc avoir deux branches (deux pointeurs) vers le dernier 
commit : la branche master et la branche tout juste créée.

Pour déterminer quel pointeur vous utilisez, c’est-à-dire sur quelle branche 
vous vous trouvez, Git utilise un autre pointeur spécial appelé HEAD.
HEAD pointe sur la branche master par défaut. Notez que la commande
:<git branch> permet de créer une nouvelle branche mais ne déplace pas HEAD.

Nous allons donc devoir déplacer explicitement HEAD pour indiquer à Git 
qu’on souhaite basculer sur une autre branche. On utilise pour cela 
la commande:<git checkout> suivi du nom de la branche sur laquelle on souhaite basculer.

-----BASCULER ENTRE LES BRANCHES---
On peut également utiliser <git checkout -b> pour créer une branche et basculer 
immédiatement dessus. Cela est l’équivalent d’utiliser git branch puis git checkout.

HEAD pointe maintenant vers notre branche test. Si on effectue un nouveau commit,
la branche test va avancer automatiquement tandis que master va toujours pointer sur le commit précédent. 
C’est en effet la branche sur laquelle on se situe lors d’un commit qui va pointer sur ce commit.

On peut revenir sur notre branche master en tapant à nouveau une commande git checkout master. 
Cela replace le pointeur HEAD sur la branche master et restaure le répertoire de travail 
dans l’état de l’instantané pointé par le commit sur lequel pointe master.

Si on modifie alors le répertoire de travail et qu’on effectue un nouveau commit, 
les deux branches master et test vont diverger. On va donc avoir deux branches 
pointant vers des instantanés qui ont enregistré le projet dans deux états différents.














 














